<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spiral Board Game - Host</title>
    <link rel="stylesheet" href="styles.css">
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Spiral Board Game</h1>
            <p>Host Control Panel</p>
        </div>

        <div id="room-setup" class="room-setup">
            <h2>Create Game Room</h2>
            <button id="createRoomBtn" class="button">Create New Room</button>
            
            <div id="roomInfo" style="display: none;">
                <h3>Room Code</h3>
                <div id="roomCode" class="room-code">----</div>
                <p>Share this code with players so they can join on their phones</p>
                
                <div class="game-level">
                    <label for="gameLevel">Game Level:</label>
                    <select id="gameLevel" class="level-select">
                        <option value="basic">Basic (Privilege/Discrimination only)</option>
                        <option value="intermediate">Intermediate (+ Social Policies)</option>
                        <option value="advanced">Advanced (All categories + Events)</option>
                    </select>
                </div>
                
                <button id="startGameBtn" class="button" disabled>Start Game (Need at least 2 players)</button>
            </div>
        </div>

        <div id="players-section" class="players-section" style="display: none;">
            <h3>Connected Players (<span id="playerCount">0</span>)</h3>
            <div id="playersGrid" class="players-grid"></div>
        </div>

        <div id="game-board" class="game-board">
            <div class="spiral-board" id="spiralBoard">
                <!-- Rings will be generated by JavaScript -->
            </div>
        </div>

        <div id="game-controls" class="game-controls" style="display: none;">
            <div id="currentPlayer" class="current-player">
                <h3>Current Player: <span id="currentPlayerName">-</span></h3>
                <p id="currentPlayerStatus">Waiting for player to draw a card...</p>
            </div>

            <!-- Card Drawn Display -->
            <div id="cardDrawnDisplay" class="card-drawn-display">
                <h3>üé¥ Card Drawn!</h3>
                <div id="cardDescription" class="card-description"></div>
                <p>All players must now make their decisions...</p>
            </div>

            <!-- Decision Phase -->
            <div id="decisionPhase" class="decision-phase">
                <h3>‚è≥ Waiting for All Players to Decide</h3>
                <div class="progress-indicator">
                    <div id="decisionProgress">Decisions: <span id="decisionsCount">0</span> / <span id="totalPlayers">0</span></div>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
                <div id="playerDecisions" class="player-decisions"></div>
                <button id="proceedBtn" class="button" onclick="proceedToNextTurn()" style="display: none;">
                    Proceed to Next Turn
                </button>
            </div>

            <div id="eventNotification" class="event-notification">
                <h4>Event Triggered!</h4>
                <p id="eventText"></p>
            </div>

            <!-- Add Draw Card Button to game-controls -->
            <div id="hostDrawCardSection" style="display:none; margin: 1.5rem 0; text-align:center;">
                <button id="hostDrawCardBtn" class="button" style="font-size:1.2rem;">üé¥ Draw Card</button>
            </div>
        </div>

        <div id="winner-announcement" class="winner-announcement">
            <h2>üèÜ Game Over!</h2>
            <p id="winnerText"></p>
            <button class="button" onclick="location.reload()">New Game</button>
        </div>
    </div>

    <script>
        const socket = io();
        let gameState = {
            roomCode: null,
            players: [],
            gameStarted: false,
            gameLevel: 'basic',
            currentPlayer: null,
            nextCardType: 'privilege-discrimination',
            phase: 'waiting', // 'waiting', 'card-drawn', 'decisions', 'moving'
            currentCard: null,
            playerDecisions: {}
        };

        // DOM elements
        const createRoomBtn = document.getElementById('createRoomBtn');
        const roomInfo = document.getElementById('roomInfo');
        const roomCodeDiv = document.getElementById('roomCode');
        const startGameBtn = document.getElementById('startGameBtn');
        const playersSection = document.getElementById('players-section');
        const playersGrid = document.getElementById('playersGrid');
        const playerCount = document.getElementById('playerCount');
        const gameBoard = document.getElementById('game-board');
        const gameControls = document.getElementById('game-controls');
        const currentPlayerName = document.getElementById('currentPlayerName');
        const currentPlayerStatus = document.getElementById('currentPlayerStatus');
        const nextCardType = document.getElementById('nextCardType');
        const winnerAnnouncement = document.getElementById('winner-announcement');
        const winnerText = document.getElementById('winnerText');
        const eventNotification = document.getElementById('eventNotification');
        const eventText = document.getElementById('eventText');

        // Phase elements
        const cardDrawingPhase = document.getElementById('cardDrawingPhase');
        const cardDrawnDisplay = document.getElementById('cardDrawnDisplay');
        const cardDescription = document.getElementById('cardDescription');
        const decisionPhase = document.getElementById('decisionPhase');
        const playerDecisions = document.getElementById('playerDecisions');
        const decisionsCount = document.getElementById('decisionsCount');
        const totalPlayers = document.getElementById('totalPlayers');
        const progressFill = document.getElementById('progressFill');
        const proceedBtn = document.getElementById('proceedBtn');

        // Card category elements
        const privilegeDiscriminationCards = document.getElementById('privilegeDiscriminationCards');
        const socialPolicyCards = document.getElementById('socialPolicyCards');
        const behaviorCards = document.getElementById('behaviorCards');

        // Add Draw Card Button to game-controls
        const hostDrawCardSection = document.getElementById('hostDrawCardSection');
        const hostDrawCardBtn = document.getElementById('hostDrawCardBtn');

        // Card samples for host to draw from
        const HOST_SAMPLE_CARDS = {
            'privilege-discrimination': [
                'You can easily find beauty products that match your skin tone.',
                'You have never been followed by security in a store.',
                'Your achievements are never questioned as diversity hires.',
                'You can walk alone at night without fear.',
                'Your name is never mispronounced or seen as difficult.',
                'You see people who look like you in leadership positions.',
                'You have never been asked to speak for your entire race/group.'
            ],
            'social-policies': [
                'A new accessibility law is passed requiring ramps in all buildings.',
                'Healthcare becomes free for all citizens.',
                'Marriage equality is legalized nationwide.',
                'Anti-discrimination laws in employment are strengthened.',
                'Public transportation becomes wheelchair accessible.',
                'Mental health support is included in all health plans.',
                'Educational funding is distributed more equally across districts.'
            ],
            'behaviors': [
                'You interrupt others in meetings without being called aggressive.',
                'You can express anger without being labeled as difficult.',
                'Your cultural holidays are recognized by your workplace/school.',
                'You can make mistakes without them being attributed to your identity.',
                'You receive mentorship and networking opportunities easily.',
                'Your accent or way of speaking is considered professional.',
                'You can discuss your weekend activities without hiding your identity.'
            ]
        };

        // Create room
        createRoomBtn.addEventListener('click', () => {
            socket.emit('create-room');
        });

        // Start game
        startGameBtn.addEventListener('click', () => {
            const level = document.getElementById('gameLevel').value;
            socket.emit('start-game', level);
        });

        // Socket events
        socket.on('room-created', (data) => {
            gameState.roomCode = data.roomCode;
            roomCodeDiv.textContent = data.roomCode;
            roomInfo.style.display = 'block';
            playersSection.style.display = 'block';
            createRoomBtn.style.display = 'none';
            createSpiralBoard();
        });

        socket.on('room-updated', (data) => {
            gameState.players = data.players;
            updatePlayersDisplay();
            updateStartButton();
        });

        socket.on('game-started', (data) => {
            gameState.gameStarted = true;
            gameState.gameLevel = data.gameLevel;
            gameState.currentPlayer = data.currentPlayer;
            gameState.nextCardType = data.nextCardType;
            gameState.phase = 'waiting';
            
            gameBoard.style.display = 'block';
            gameControls.style.display = 'block';
            startGameBtn.style.display = 'none';
            
            updateCurrentPlayer(data.currentPlayer);
            updateCardInterface();
            updatePlayerPositions();
            updatePhaseDisplay();
            showHostDrawCardButton(data.nextCardType);
        });

        socket.on('card-drawn', (data) => {
            gameState.currentCard = data.card;
            gameState.phase = 'decisions';
            gameState.playerDecisions = {};
            // Show card drawn on host
            cardDrawnDisplay.classList.add('show');
            cardDescription.innerHTML = `
                <strong>${data.card.cardType || data.card.category || ''}</strong><br>
                ${data.card.description || data.card.text || `Move ${data.card.steps > 0 ? 'forward' : 'backward'} ${Math.abs(data.card.steps)} ring${Math.abs(data.card.steps) !== 1 ? 's' : ''}`}
            `;
            updatePhaseDisplay();
            updateDecisionProgress();
            updateCurrentPlayer(data.cardDrawnBy);
            hideHostDrawCardButton();
        });

        socket.on('player-decision', (data) => {
            // Update progress bar and player decision display
            gameState.playerDecisions[data.playerId] = data.decision;
            updateDecisionProgress();
            updatePlayerDecisionDisplay();
        });

        socket.on('all-decisions-made', (data) => {
            gameState.phase = 'moving';
            gameState.players = data.allPlayers;
            gameState.currentPlayer = data.nextPlayer;
            gameState.nextCardType = data.nextCardType;
            // Update player positions
            updatePlayerPositions();
            // Show events if triggered
            if (data.eventsTriggered && data.eventsTriggered.length > 0) {
                showEventNotification(data.eventsTriggered);
            }
            // Check for winner
            if (data.winner) {
                showWinner(data.winner);
            } else {
                // Show proceed button
                proceedBtn.style.display = 'block';
            }
            updateCurrentPlayer(data.nextPlayer);
            // Host waits for ready-for-next-card event to re-enable draw
        });

        socket.on('turn-ended', (data) => {
            gameState.phase = 'waiting';
            gameState.currentPlayer = data.nextPlayer;
            gameState.nextCardType = data.nextCardType;
            gameState.playerDecisions = {};
            updateCurrentPlayer(data.nextPlayer);
            updateCardInterface();
            updatePhaseDisplay();
        });

        socket.on('player-moved', (data) => {
            gameState.players = data.allPlayers;
            updatePlayerPositions();
            updatePlayersDisplay();
        });

        socket.on('game-ended', (data) => {
            showWinner(data.winner);
        });

        socket.on('host-disconnected', () => {
            alert('Host has disconnected. Game ended.');
            location.reload();
        });

        socket.on('error', (error) => {
            alert('Error: ' + error);
        });

        socket.on('ready-for-next-card', (data) => {
            gameState.nextCardType = data.nextCardType;
            showHostDrawCardButton(data.nextCardType);
        });

        // Functions
        function updatePlayersDisplay() {
            playersGrid.innerHTML = '';
            playerCount.textContent = gameState.players.length;
            
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                playerCard.style.borderLeftColor = player.color;
                
                // Add status indicators during decision phase
                let statusHTML = '';
                if (gameState.phase === 'decisions') {
                    const hasDecided = gameState.playerDecisions[player.id] !== undefined;
                    playerCard.classList.add(hasDecided ? 'decided' : 'waiting');
                    statusHTML = `<div style="padding: 5px; font-size: 12px; color: ${hasDecided ? '#27ae60' : '#f39c12'}; font-weight: bold;">
                        ${hasDecided ? '‚úì Decision Made' : '‚è≥ Waiting...'}
                    </div>`;
                }
                
                playerCard.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="player-identity">${player.identityName} ${player.icon}</div>
                    <div class="player-position">Ring: ${player.position}</div>
                    ${statusHTML}
                `;
                playersGrid.appendChild(playerCard);
            });
        }

        function updateStartButton() {
            const canStart = gameState.players.length >= 2;
            startGameBtn.disabled = !canStart;
            startGameBtn.textContent = canStart ? 
                `Start Game (${gameState.players.length} players)` : 
                'Start Game (Need at least 2 players)';
        }

        function createSpiralBoard() {
            const board = document.getElementById('spiralBoard');
            board.innerHTML = '';
            
            const boardSize = 600;
            const center = boardSize / 2;
            const eventRings = [5, 10, 15, 20];
            
            // Create rings from outer (21) to inner (1)
            for (let ring = 21; ring >= 1; ring--) {
                const ringElement = document.createElement('div');
                ringElement.className = `ring ${eventRings.includes(ring) ? 'event-ring' : ''}`;
                ringElement.id = `ring-${ring}`;
                
                const radius = (ring / 21) * (boardSize / 2 - 20);
                const size = radius * 2;
                
                ringElement.style.width = `${size}px`;
                ringElement.style.height = `${size}px`;
                ringElement.style.left = `${center - radius}px`;
                ringElement.style.top = `${center - radius}px`;
                
                // Add ring number
                const ringNumber = document.createElement('div');
                ringNumber.className = 'ring-number';
                ringNumber.textContent = ring;
                ringElement.appendChild(ringNumber);
                
                board.appendChild(ringElement);
            }
        }

        function updatePlayerPositions() {
            // Remove existing pawns
            document.querySelectorAll('.pawn').forEach(pawn => pawn.remove());
            
            gameState.players.forEach((player, index) => {
                const pawn = document.createElement('div');
                pawn.className = 'pawn';
                pawn.style.backgroundColor = player.color;
                pawn.title = `${player.name} (${player.identityName})`;
                
                const ring = document.getElementById(`ring-${player.position}`);
                if (ring) {
                    // Position pawns around the ring
                    const angle = (index * (360 / gameState.players.length)) * (Math.PI / 180);
                    const ringRadius = parseFloat(ring.style.width) / 2;
                    const pawnRadius = Math.max(10, ringRadius - 30);
                    
                    const x = Math.cos(angle) * pawnRadius;
                    const y = Math.sin(angle) * pawnRadius;
                    
                    pawn.style.left = `${parseFloat(ring.style.left) + parseFloat(ring.style.width)/2 + x - 10}px`;
                    pawn.style.top = `${parseFloat(ring.style.top) + parseFloat(ring.style.height)/2 + y - 10}px`;
                    
                    document.getElementById('spiralBoard').appendChild(pawn);
                }
            });
        }

        function updateCurrentPlayer(player) {
            if (player) {
                currentPlayerName.textContent = `${player.name} (${player.identityName})`;
                currentPlayerName.style.color = player.color;
            }
        }

        function updateCardInterface() {
            // Update next card type indicator
            const cardTypeMap = {
                'privilege-discrimination': 'Privilege/Discrimination',
                'social-policies': 'Social Policies',
                'behaviors': 'Behaviors'
            };
            
            nextCardType.textContent = cardTypeMap[gameState.nextCardType] || gameState.nextCardType;
            
            // Show/hide appropriate card categories
            privilegeDiscriminationCards.style.display = gameState.nextCardType === 'privilege-discrimination' ? 'flex' : 'none';
            socialPolicyCards.style.display = gameState.nextCardType === 'social-policies' ? 'flex' : 'none';
            behaviorCards.style.display = gameState.nextCardType === 'behaviors' ? 'flex' : 'none';
        }

        function updatePhaseDisplay() {
            // Hide all phase displays
            cardDrawingPhase.style.display = 'none';
            cardDrawnDisplay.classList.remove('show');
            decisionPhase.classList.remove('show');
            proceedBtn.style.display = 'none';
            
            switch (gameState.phase) {
                case 'waiting':
                    currentPlayerStatus.textContent = 'Waiting for player to draw a card...';
                    break;
                case 'decisions':
                    cardDrawnDisplay.classList.add('show');
                    decisionPhase.classList.add('show');
                    currentPlayerStatus.textContent = 'Card drawn - waiting for all players to decide';
                    break;
                case 'moving':
                    currentPlayerStatus.textContent = 'All players have decided - processing moves';
                    break;
            }
            updatePlayersDisplay();
        }

        function updateDecisionProgress() {
            const totalPlayerCount = gameState.players.length;
            const decisionsReceived = Object.keys(gameState.playerDecisions).length;
            
            decisionsCount.textContent = decisionsReceived;
            totalPlayers.textContent = totalPlayerCount;
            
            const percentage = totalPlayerCount > 0 ? (decisionsReceived / totalPlayerCount) * 100 : 0;
            progressFill.style.width = `${percentage}%`;
        }

        function updatePlayerDecisionDisplay() {
            playerDecisions.innerHTML = '';
            
            gameState.players.forEach(player => {
                const decision = gameState.playerDecisions[player.id];
                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 10px;
                    margin: 5px 0;
                    border-left: 4px solid ${player.color};
                    background: ${decision ? '#f8f9fa' : '#fff3cd'};
                    border-radius: 5px;
                `;
                
                playerDiv.innerHTML = `
                    <div>
                        <div style="font-weight: bold;">${player.name}</div>
                        <div style="font-size: 12px; color: #666;">${player.identityName}</div>
                        ${decision ? `<div style="color: #27ae60; font-size: 12px; margin-top: 2px;">${decision.description}</div>` : '<div style="color: #856404; font-size: 12px;">Waiting for decision...</div>'}
                    </div>
                    <div style="font-size: 20px;">
                        ${decision ? (decision.direction === 'forward' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è') : '‚è≥'}
                    </div>
                `;
                
                playerDecisions.appendChild(playerDiv);
            });
        }

        function drawCard(category, steps, cardType) {
            const cardData = {
                category: category,
                steps: steps,
                cardType: cardType,
                description: `${cardType} card: ${steps > 0 ? '+' : ''}${steps} rings`
            };
            
            socket.emit('draw-card', cardData);
        }

        function proceedToNextTurn() {
            socket.emit('proceed-to-next-turn');
        }

        function showEventNotification(events) {
            if (events.length > 0) {
                const event = events[0]; // Show first event
                eventText.textContent = `${event.player.name} landed on ring ${event.player.position}: ${event.event.name} - ${event.event.description}`;
                eventNotification.classList.add('show');
                
                setTimeout(() => {
                    eventNotification.classList.remove('show');
                }, 8000);
            }
        }

        function showWinner(winner) {
            winnerText.innerHTML = `<strong>${winner.name}</strong> (${winner.identityName}) has reached the center and won the game!`;
            winnerAnnouncement.style.display = 'block';
            gameControls.style.display = 'none';
        }

        function showHostDrawCardButton(cardType) {
            hostDrawCardSection.style.display = 'block';
            hostDrawCardBtn.disabled = false;
            hostDrawCardBtn.textContent = `üé¥ Draw ${cardType.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase())} Card`;
        }

        function hideHostDrawCardButton() {
            hostDrawCardSection.style.display = 'none';
        }

        // Draw card logic for host
        hostDrawCardBtn.addEventListener('click', () => {
            hostDrawCardBtn.disabled = true;
            // Pick a random card from the correct category
            const cardType = gameState.nextCardType;
            const cards = HOST_SAMPLE_CARDS[cardType] || ['Default card'];
            const randomCard = cards[Math.floor(Math.random() * cards.length)];
            const cardData = {
                category: cardType,
                description: randomCard,
                text: randomCard
            };
            socket.emit('draw-card', cardData);
            hideHostDrawCardButton();
        });
    </script>
</body>
</html>